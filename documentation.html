<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Swt-gui-transformer by milanaleksic</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="stylesheets/lightbox.css">
    <script src="javascripts/jquery-1.7.2.min.js"></script>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/lightbox.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
<header>
    <h1>swt-gui-transformer</h1>

    <p>&quot;JSON â†’ SWT shells&quot; GUI Transformer tool for Java delopers</p>

    <p class="view"><a href="https://github.com/milanaleksic/swt-gui-transformer">View the Project on GitHub
        <small>milanaleksic/swt-gui-transformer</small>
    </a></p>
    <ul>
        <li><a href="https://github.com/milanaleksic/swt-gui-transformer/zipball/master">Download <strong>ZIP
            File</strong></a></li>
        <li><a href="https://github.com/milanaleksic/swt-gui-transformer/tarball/master">Download <strong>TAR
            Ball</strong></a></li>
        <li><a href="https://github.com/milanaleksic/swt-gui-transformer">View On <strong>GitHub</strong></a></li>
    </ul>
</header>
<section>
    <blockquote>Wish to see <a href="index.html">just the basics</a>?</blockquote>

    <h1>Documentation</h1>

    <h2>Overview</h2>

    <p>You use SGT to convert JSON to create SWT beans using:</p>
    <ol>
        <li><a href="#explicit-notation">explicit class mention</a>,</li>
        <li><a href="#shortcut-notation">shortcut notation</a> or</li>
        <li><a href="#builder-notation">builder notation</a>.</li>
    </ol>
    <p>and then to configure them using property setters, you should just make sure the property
        you are setting value to is exposed in the means of setter method or public field.</p>

    <p>SGT uses type information to find out which <a href="#converters">converter</a> to use to map the JSON node
        value to the target object.</p>

    <p>If you wish to add <em>children widgets</em> to the current widget, or to know how to <em>name the widget</em>,
        or to define types you need to know everything about the <a href="#special-tags">special tags</a>.</p>

    <p>If you wish to use resource bundle messages, images or beans injections into SWT (or your custom) beans you
        should definitely take a look at how to implement <a href="#providers">providers</a>.</p>

    <p>Finally, after you have finished working with the user interface, you need to be able to use all those widgets
        and to react on their events, right? Take a look how I implemented events and widgets annotation-driven <a
                href="#embedding">embedding</a> and how to, finally, <a href="#wiring">transform the form</a>.</p>

    <h2 id="creation-notations">Creation notations</h2>

    <h3 id="explicit-notation">Explicit class mention</h3>

    <p>To <strong>create</strong> beans using this approach, you should use the special tag <strong>_type</strong>
        to note exact class you wish to instantiate:</p>

        <pre>    {
        "_type" : "org.eclipse.swt.widgets.Label",
        .....
    }</pre>

    <h3 id="shortcut-notation">Shortcut notation</h3>

    <p>This approach is used to make definition writing faster since it allows you to use short type identifiers
        instead of full class names.</p>

        <pre>    {
        "_type" : "label",
        .....
    }</pre>

    <p>If you wish to see entire list of supported shortcuts out-of-the-box in SGT, take a look at the
        current version's <code>knownShortcuts</code> field in
        <a href="https://github.com/milanaleksic/swt-gui-transformer/blob/master/swt-gui-transformer-core/src/main/java/net/milanaleksic/guitransformer/ObjectConverter.java">ObjectConverter
            class</a>.</p>

    <h4>Wish to extend?</h4>

    <p>If you wish to extend the list of the items to use some additional SWT classes or if you wish to
        use shortcuts for your own widgets, you can create properties file <code>/META-INF/guitransformer.shortcuts.properties</code>
        like I did it in <a
                href="https://github.com/milanaleksic/MovieCatalogSystem/blob/master/source/java/META-INF/guitransformer.shortcuts.properties">MovieCatalogSystem</a>.
        If you use this approach and wish to use SGT's interactive editor for your project's GUI files,
        just include the compiled output to the editor's classpath.
    </p>

    <h3 id="builder-notation">Builder notation</h3>

    <p>For some complex cases it is too exhausting to set all properties manually, especially if the widget
        appears too often. Builder pattern should help you with this problem by lowering the amount of text
        you need to enter to get the same result.</p>

    <p>Notation is as follows:</p>

    <pre>    [builderName](param1,param2...)</pre>

    <p>The param count is generic. Implementation of <code>net.milanaleksic.guitransformer.Builder&lt;T&gt;</code>
        has only one method <code>create</code> that gets List of all parameters.</p>

    <p>You can use builder notation in 2 different ways:</p>
    <ol>
        <li>as a String value,</li>
        <li>as the value for <strong>_type</strong> in the JSON object notation.</li>
    </ol>
    <p>First approach is trivial - it lets builder do entire task for creating the object:</p>

    <pre>    "someProperty" : "[myBuilder](param1,param2)"</pre>

    <p>But, in case you need to further customize the object created by the builder, use second approach:</p>

    <pre>    "someProperty" : {
        "_type": "[myBuilder](param1,param2)",
        "param3" : "valueForParam3"
    }</pre>

    <h4>Example: GridDataBuilder</h4>

    <p>Builder notation is used in SGT to replace creation of the <code>org.eclipse.swt.layout.GridData</code>
        object which can be quite cumbersome if you base you layout on it a lot. Using <code>GridDataBuilder</code>
        you can replace following block of code:</p>

        <pre>   "_type" : "composite",
    "layoutData" : {
        "_type" : "gridData",
        "horizontalAlignment" : "{center}", // what are these {???} things? Wait for Integer Converter part
        "verticalAlignment" : "{beginning}",
        "grabExcessHorizontalSpace" : true,
        "grabExcessVerticalSpace" : false
    },</pre>

    <p>with following shorter variant:</p>

        <pre>    "_type" : "composite",
    "layoutData" : "[gridData](center,begin,true,false)"</pre>

    <p>This builder has variants of 4 and 6 parameters, where the 6-param version also accepts
    horizontalSpan and verticalSpan properties to be set. But what if you have to set some additional
    field for GridData, like <code>heightHint</code>? Easy, use the object + builder notation approach:</p>

    <pre>    "layoutData" : {
        "_type" : "[gridData](fill,fill,true,true,1,3)",
        "heightHint" : 180
    },</pre>

    <h4>Wish to extend?</h4>

    <p>First, you need to make your own implementations of interface <code>net.milanaleksic.guitransformer.Builder&lt;T&gt;</code>.
    </p>

    <p>Second thing to do is to use DI and extend the <code>net.milanaleksic.guitransformer.guice.CoreModule</code>
        and implement your own <code>prepareRegisteredBuildersForObjectConverter</code> method if you're using
        Guice or just introduce more mappings in Spring configuration for field <code>registeredBuilders</code>
        for bean of type <code>net.milanaleksic.guitransformer.ObjectConverter</code>.</p>

    <h2 id="converters">Converters</h2>

    <p>Converters are critical to the SGT application. JSON only recognizes Strings, booleans and number values.
        How can you possibly map a <code>TabItem</code>? The trick is in converters - they are specialized
        for converting a JSON node (which can be text, number, boolean, array or object node) into a specific
        <strong>target type</strong>.</p>

    <p>To detect target type, SGT uses type introspection at runtime. For example, when it encounters
        a field of type <code>int</code>, it will use <code>IntegerConverter</code> to convert the value
        on the right side of JSON property to appropriate type - int. IntegerConverter is, though, more
        powerful because it has magic value notation, which you can read in details later.</p>

    <p>Using dependency injection you can extend the currently supported list to other items as well. </p>

    <p>Currently supported converters (most of them are in package <code>net.milanaleksic.guitransformer.typed</code>)
        are:</p>

    <ol>
        <li><a href="#boolean-converter"><code>BooleanConverter</code></a></li>
        <li><a href="#color-converter"><code>ColorConverter</code></a></li>
        <li><a href="#integer-converter"><code>IntegerConverter</code></a></li>
        <li><a href="#font-converter"><code>FontConverter</code></a></li>
        <li><a href="#image-converter"><code>ImageConverter</code></a></li>
        <li><a href="#point-converter"><code>PointConverter</code></a></li>
        <li><a href="#string-converter"><code>StringConverter</code></a></li>
        <li>if none is appropriate - fallback to
            <a href="#object-converter"><code>net.milanaleksic.guitransformer.ObjectConverter</code></a></li>
    </ol>

    <h4 id="boolean-converter">BooleanConverter</h4>

    <p>This converter is the most basic one - it just converts the JSON native boolean value to Java's. Nothing else
        to it.</p>

    <h4 id="color-converter">ColorConverter</h4>

    <p>This converter can be used in 2 different ways:</p>
    <ol>
        <li>it allows you to use classic CSS color notation in GUI files (which is in my opinion cool),</li>
        <li>you can reference SWT system colors by using the name of the color in <em>lowercase</em>.</li>
    </ol>
    <pre>    {
        "_type" : "label",
        "foreground" : "#0000ff",              // HTML/CSS color definition: r:0, g:0, b:255
        "background" : "color_list_foreground" // system color org.eclipse.swt.SWT.COLOR_LIST_FOREGROUND
    }</pre>

    <h4 id="integer-converter">IntegerConverter</h4>

    <p>Allows not only exact integer value to be placed as property value, but also to use magic number notation
        to reference the colors from the SWT class (but in lower case). This approach can be combined with
        the special tag <strong>_style</strong> used to set the widget's style when creating instance.
    </p>

    <p>Since it is quite often needed to use bitwise OR when declaring values (styles before all else),
        IntegerConverter also accepts OR operator:</p>

    <pre>    {
        "_type" : "text",
        "_style" : "{multi}|{wrap}|{v_scroll}|{border}" // SWT.MULTI | SWT.WRAP | SWT.V_SCROLL | SWT.BORDER
    }</pre>

    <h4 id="font-converter">FontConverter</h4>
    <p>This converter expects an object notation on the right side of the property with one of following
        properties:</p>
    <ol>
        <li><code>name</code> - font name face,</li>
        <li><code>height</code> - height of the font</li>
        <li><code>style</code> - it can be set to text values <strong>bold</strong> or <strong>italic</strong></li>
    </ol>
    <p>For whatever is not set, FontConverter will use values from default system font.</p>
    <pre>    {
        "_type" : "label",
        "font" : {
            "height" : 12,
            "style" : "bold",
            "name" : "Courier New"
        }
    }</pre>

    <h4 id="image-converter">ImageConverter</h4>
    <p>This converter just delegates the image name to image provider to do whatever it wants with it.</p>
    <p>For example, in MCS I have image provider implementation that uses the value as a full path
        to the location in application resources, from where it fetches it for SGT to embed.</p>

    <pre>    {
        "_type" : "toolItem",
        "image" : "/net/milanaleksic/mcs/application/res/media.png"
    }</pre>

    <h4 id="point-converter">PointConverter</h4>
    <p>Very basic converter that uses simple string pattern <code>x,y</code> as the value definition.</p>
    <pre>    {
        "_type" : "shell",
        "size" : "412,326"
    }</pre>

    <h4 id="string-converter">StringConverter</h4>
    <p>What ever string you enter on the right side of the property, it will be set in the bean's property.</p>
    <p>If you put part of the text in the square brackets ([]), messageProvider will be asked for the value
        behind it. That should be, most logically, a String from the resourceBundle for the current application
        locale, but doesn't have to be.</p>

    <pre>    {
        "_type" : "label",
        "text" : "[delete.doYouReallyWishToDeleteMovie]"
    }</pre>

    <h4 id="object-converter">ObjectConverter</h4>
    <p>Object converter is the <strong>fallback converter</strong>. This means that when SGT finds a field
        which type is not directly registered in the list of converters, it goes to <code>ObjectConverter</code>
        and says "Help!".</p>

    <h5>Providing objects using injection and providers</h5>

    <p>First thing ObjectConverter tries to do is to check if the object is maybe in <strong>injected object</strong>
        notation, which means that instead of creating it it needs to <strong>provide</strong> it.
        The injected object notation is:</p>

    <pre>    "(objectName)"</pre>

    <p>Providing the object is two-phase process: first the named objects in the current context are browsed.
        You can use the special tag <strong>_name</strong> to give name to any bean. This is extremely useful
        when working on containers like TabFolder, where you first need to create container contents widget
        (Composite for example) and then create TabItem with the previously created widget as the <em>control</em>:
    </p>

    <pre>    {
        "_type" : "composite",
        "_name" : "<em>settingsTab</em>"
    }
    {
        "_type" : "tabItem",
        "text" : "[settings.basicSettings]",
        "control" : "<em>(settingsTab)</em>"
    }</pre>

    <p>If none named bean is found <code>ObjectProvider</code> is asked for the object under the name used.
        If you implemented Object Provider to fetch the object from DI using the name, you can easily inject
        a bean in custom SWT widgets.</p>

    <pre>    {
        "_type" : "myCustomComponent",
        "bundle" : "(resourceBundle)" // resourceBundle can be Spring bean for example!
    }</pre>

    <h5>Object creation</h5>

    <p>If the injected object notation is <strong>not</strong> used, ObjectConverter tries to render the value of the
        property setter as JSON object and finds in it the special tag <code>_type</code> to see which type of
        object it needs to instantiate before proceeding with property setting. If you jumped over the first topic
        of the documentation - creation notations, now is a good time to <a href="#creation-notations">read it</a>.</p>

    <h2 id="special-tags">Special tags</h2>
    <p>Special tags are used for various situations where there is no way to do it differently. Practically, special
    tags are only JSON node names which are not based on the property name in the target widget / bean.</p>

    <h3>_type tag</h3>
    <p>This tag is used in object nodes to say which class/builder/shortcut to use to create the object. More details
    in the <a href="#creation-notations">creation notations</a> part.</p>

    <h3>_children tag</h3>
    <p>What is quite specific for SWT widgets, controls etc is their constructor. More specifically, they don't have
        no-arg constructor. If you wish to create a new widget, you have to explicitly say what is the parent
        and what is the style (or style mix) you wish to enforce.</p>

    <p>This tag allows creation of "children" components meaning that when items inside it are created the parent will
        be set to the bean that has the "_children" tag. If you wish to make shell with two labels you do it
        like this:
    </p>

    <pre>    {
        "_type" : "shell",
        "size" : "150,150",
        "layout" : {
            "_type" : "org.eclipse.swt.layout.RowLayout"
        },
        "_children" : [
            {
                "_type" : "label",
                "text" : "first label"
            },
            {
                "_type" : "label",
                "text" : "second label"
            }
        ]
    }</pre>

    <h3>_style tag</h3>
    <p>Since style is set during the creation of the SWT widgets, normal setter does not exist. That was the
        reason for inclusion of this tag. Since style is of integer type, you are using <a href="#integer-converter">>IntegerConverter</a>
        when setting the value, which gives you the freedom of using SWT's magic constants.</p>

    <h3>_name tag</h3>
    <p>Name tag has a single usage - putting the widget in the TransformationContext. This context object
        is the one you get after calling transformation on the GUI file from the Transformer (SGT entry point).</p>

    <p>After you have named some widget, you will be able to reference that object inside:</p>

    <ol>
        <li>the same GUI file (you have the example for this in <a href="#object-converter">ObjectConverter part</a>)</li>
        <li>you can attach event listeners in the Java code to it using the name of the reference
            using <code>@EmbeddedEventListener</code>/<code>@EmbeddedEventListeners</code> annotations,</li>
        <li>you can embed (inject) the widget reference in the code using <code>@EmbeddedComponent</code>,</li>
        <li>you can dereference named widgets from the transformationContext using call
            <code>net.milanaleksic.guitransformer.TransformationContext.getMappedObject(String name)</code>.</li>
    </ol>

    <p>Examples for the reference and event embedding are given in the <a href="#embedding">embedding part</a>.</p>

    <h3>__comment tag</h3>
    <p>This is trivial special tag to be used if you have need to comment something in the GUI code. As you know,
        JSON should not have comments so the only way to have a proper JSON is to use a custom JSON field. So,
        just put it in any object definition and put in the value field whatever you wish - it will not be
        taken into consideration by SGT.</p>

    <pre>    {
        "_type" : "label",
        "__comment" : "This is a comment in the GUI file!"
    }</pre>


    <h2 id="providers">Providers</h2>

    <p>If I believe there is an extension point that you will really really like to use, there is a provider
        interface for it. You use your dependency injection framework to say "here is the implementor for the
        provider", and like magic you'll see our application messages, images from your resources or external
        location or even <strong>other beans</strong> from your DI framework showing up as possible candidates
        for wiring into SGT definition JSONs.</p>

    <h3>Messages string provider</h3>

    <p>Use your DI container to override
        <code>net.milanaleksic.guitransformer.providers.ResourceBundleProvider</code>
        with your implementation or just route it to SimpleResourceBundleProvider to always use
        messages_en.properties (or default messages.properties if first does not exist) as the source for resource
        naming pattern for string properties. For example:</p>

    <pre>    {
        "_type" : "label",
        "text" : "[string.from.resources]"
    }</pre>

    <h3>Object provider</h3>

    <p>When you use named object syntax to ask from the DI for a named object in JSON definition,
        you basically ask it from implementation of
        <code>net.milanaleksic.guitransformer.providers.ObjectProvider</code>
        you registered in the DI container.
        You can though use AlwaysReturnNullObjectProvider to always embed null when named object is requested, for
        example:</p>

    <pre>    {
        "_type" : "net.milanaleksic.application.MyCustomSWTComponent",
        "someReallyCoolCustomObjectFromSpring" : "(customSpringObject)"
    }</pre>

    <h3>Images provider</h3>

    <p>Use your DI container to override <code>net.milanaleksic.guitransformer.providers.ImageProvider</code>
        with your implementation or just route it to AlwaysReturnEmptyImageProvider to always embed dummy image
        with the value of the JSON value node for the image setter.</p>

    <h2 id="embedding">Embedding</h2>
    <p>Embedding is the process of wiring back to code all that you created in the interface GUI files.
    To be able to reference widgets (or other beans) you created in the GUI file they have to be named
    using special tag <strong>_name</strong>.</p>

    <p>Java files that have identical name and package position as the GUI file are called <strong>managed forms</strong>
        since you can embed components and event listeners directly using the
        <code>net.milanaleksic.guitransformer.Transformer.fillManagedForm(Shell parent, Object managedFormObject)</code>.
        When Transformer analyzes the managedFormObject it will find all the fields with embedding annotations
        and either inject values into them or attach listeners, depending on the annotation. It is
        important to remember that SGT expects the GUI file to be named exactly like the Java managedFormObject
        from the call, just having <strong>.gui</strong> instead of java/class.</p>

    <h3>EmbeddedComponent</h3>
    <p>This annotation can be used on fields (should be but don't <em>have to be</em> private) in the form file.</p>
    <p>So, if you have a field named "myLabel" in the GUI file:</p>
    <pre>    {
        "_type" : "label",
        "_name" : "myLabel"
    }</pre>
    <p>in the managed form Java file you just mark the appropriate field with the annotation:</p>
    <pre>    @EmbeddedComponent
    private Label myLabel;</pre>
    <p>After transformation, you can just dereference the value in it - it will be injected by SGT.</p>

    <h3>@EmbeddedEventListener and @EmbeddedEventListeners</h3>
    <p>To wire event listeners you also need just to reference the component with the name and
        then ask for a specific event to attach the listener to. Listener implementation fields
        can be <em>but don't have to be</em> static.</p>
<pre>    @EmbeddedEventListener(component="myLabel", event= SWT.Selection)
    private final Listener myLabelSelectionListener  = new Listener() {
        public void handleEvent(Event event) {
            // handle event
        }
    }</pre>
    <p>Latter annotation (<code>EmbeddedEventListeners)</code> is just a helper annotation in cases
        where you want to use same listener implementation for multiple event sources for one or more
        event sources:</p>
    <pre>     @EmbeddedEventListeners({
            @EmbeddedEventListener(component = "comboMediumType", event = SWT.Selection),
            @EmbeddedEventListener(component = "comboMediumType", event = SWT.Modify),
            @EmbeddedEventListener(component = "comboGenre", event = SWT.Selection)
    })
    private final Listener complexListener  = new Listener() {
        public void handleEvent(Event event) {
            // handle event
        }
    }</pre>

    <h3>Wiring it all up</h3>
    <p>Transformer should already have all of its dependencies wired before calling it using your
    dependency injection. Guice and Spring are the frameworks I used:</p>

    <ol>
        <li>if you use Spring, take a look at <a href="https://github.com/milanaleksic/MovieCatalogSystem/blob/master/source/java/spring-beans-transformer.xml">
            XML wiring used in the MovieCatalogSystem</a>,</li>
        <li>if you use Guice, there is already a <a href="https://github.com/milanaleksic/swt-gui-transformer/blob/master/swt-gui-transformer-core/src/main/java/net/milanaleksic/guitransformer/guice/CoreModule.java">
            basic module</a> defined in the SGT code.</li>
    </ol>

    <p>The code for wiring the form and GUI file uses the entry point to SGT - <code>Transformer</code>.</p>
    <p>On the basics page you have <a href="index.html#wiring-example">entire example</a> how to use the
        Transformer to transform one form file.</p>

</section>
</div>
<footer>
    <p>Project maintained by <a href="https://github.com/milanaleksic">milanaleksic</a></p>

    <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
</footer>
<!--[if !IE]>
<script>fixScale(document);</script><!--<![endif]-->
<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' " +
            "type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-31731496-1");
        pageTracker._trackPageview();
    } catch(err) {
    }
</script>

</body>
</html>